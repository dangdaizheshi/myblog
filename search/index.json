[{"content":"Day 1 任务：Python开发环境搭建与“Hello World” 1. 检查并准备 $Python$ 环境 打开终端 输入命令：python --version 请确保 $Python$ 版本是 3.9 或更高 2. 创建专属项目目录（建议长期保持）： 1 2 3 # 在你想存放代码的地方（如桌面或文档文件夹）打开终端，然后执行： mkdir ai_learning cd ai_learning 3. 创建虚拟环境： 在 ai_learning 目录下，运行： 1 2 3 4 # Windows python -m venv venv # Mac/Linux python3 -m venv venv 4. 激活虚拟环境： Windows (PowerShell)： 1 .\\venv\\Scripts\\Activate.ps1 Windows (CMD)： 1 venv\\Scripts\\activate.bat 激活成功的标志：你的命令行提示符前面会显示 (venv)，如下图所示。 1 2 (venv) D:\\ai_learning\u0026gt; # Windows示例 (venv) $ # Mac/Linux示例 5. 创建并编辑Python文件： 在 ai_learning 目录下，创建一个新文件 hello.py。 用任何文本编辑器（推荐VSCode或PyCharm）打开它，输入以下内容： 1 2 if __name__ == \u0026#34;__main__\u0026#34;: print(\u0026#34;Hello, AI World! My environment is ready.\u0026#34;) 在激活了 (venv) 的终端里，运行： 1 python hello.py 6. Day01 任务完成 Day 2 任务：用FastAPI创建你的第一个Web API 第一步：在虚拟环境中安装必要库 确保你仍在 ai_learning 目录下，且虚拟环境已激活（命令行前有(venv)）。 安装FastAPI和用于运行它的服务器： 1 pip install fastapi uvicorn 将已安装的包列表保存到文件，这是一个好习惯： 1 pip freeze \u0026gt; requirements.txt 这会生成一个 requirements.txt 文件，记录了项目依赖。 第二步：创建并编写FastAPI应用 在 ai_learning 目录下，创建一个名为 main.py 的新文件。 编写main.py中的内容 在终端执行： 1 uvicorn main:app --reload --host 0.0.0.0 --port 8000 参数解释： main:app：main是文件名，app是代码中创建的实例名 --reload：代码修改后自动重启服务器（仅开发使用）。 --host 0.0.0.0：允许本地所有网络接口访问。 --port 8000：指定端口为8000。 打开浏览器，直接访问 http://localhost:8000。就可以看到一个JSON对象显示欢迎信息。 如果访问 http://localhost:8000/docs 你会看到一个Swagger UI界面 Day02任务完成 Day 3：学习请求与响应模型 1. 创建新的练习文件 在 ai_learning 目录下（与 main.py 同级），创建一个新文件 day3_todo.py。 2. 编写 day3_todo.py 代码创建一个“待办事项”API模块。 3. 设计一个 PATCH /todos/{todo_id} 接口，用于部分更新一个事项（例如只更新 is_completed 字段） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class TodoUpdate(BaseModel): \u0026#34;\u0026#34;\u0026#34;用于部分更新待办事项的请求模型（所有字段都是可选的）\u0026#34;\u0026#34;\u0026#34; title: Optional[str] = Field(None, min_length=1, max_length=100) description: Optional[str] = Field(None, max_length=500) is_completed: Optional[bool] = None priority: Optional[int] = Field(None, ge=1, le=5) @app.patch(\u0026#34;/todos/{todo_id}\u0026#34;) async def update_todo( todo_id: int = Path(..., title=\u0026#34;要更新的待办事项ID\u0026#34;, gt=0), update_data: TodoUpdate = None ): result = None for i, item in enumerate(fake_todos_db): if item.id == todo_id: result = item break if not result: raise HTTPException(status_code=404, detail=f\u0026#34;未找到ID为 {todo_id} 的待办事项\u0026#34;) update_dict = update_data.dict(exclude_unset=True) if not update_dict: raise HTTPException( status_code=400, detail=\u0026#34;未提供任何更新字段。请至少提供一个字段，如\u0026#39;title\u0026#39;、\u0026#39;is_completed\u0026#39;等。\u0026#34; ) updated_todo = result.copy(update=update_dict) fake_todos_db[i] = updated_todo return updated_todo 4.实践：在终端新建一个标签页，使用curl命令测试API： 1 2 3 4 # 测试GET curl http://localhost:8000 # 测试POST curl -X POST \u0026#34;http://localhost:8000/echo\u0026#34; -H \u0026#34;Content-Type: application/json\u0026#34; -d \u0026#34;{\\\u0026#34;message\\\u0026#34;:\\\u0026#34;使用curl测试\\\u0026#34;}\u0026#34; ","date":"2025-12-02T13:10:22+08:00","image":"https://dangdaizheshi.github.io/myblog/p/python%E7%AC%94%E8%AE%B0/baokemeng_hu9009702813104207872.png","permalink":"https://dangdaizheshi.github.io/myblog/p/python%E7%AC%94%E8%AE%B0/","title":"python笔记"},{"content":"欧拉定理： 欧拉定理：当 $a$ 与 $mod$ 互质时，a ^ phi(mod) % mod = 1\n扩展欧拉定理：无论 $a$ 与 $mod$ 是否互质，a ^ b % mod = a ^ (b % phi(mod) +phi(mod)) % mod\n印象深刻的一道题 ：\n毒瘤数据结构题\n题意：给你一个长为 $n$，初始全为 $0$ 的序列，有 $n$ 次操作，每次可以：\n1 x 表示把 $x$ 位置修改为 $1$。\n2 x 表示查询，如果将 $x$ 位置修改为 $1$，求最大的 $i$ 满足序列位置 $1$ 到 $i-1$ 上的值均为 $1$。这里不实际上做出这一次修改。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 5000005; int n, m, l, r, p, t, k, ans, sum, tot, cnt, a[N], b[N], c[N], L[N], R[N]; // b[i] 表示 i 之后连续 1 的长度, L[i] 为 i 左侧第一个 0 的位置 inline int read() { int x = 0, f = 1; char ch = getchar(); while(ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) { if(ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar(); } while(\u0026#39;0\u0026#39; \u0026lt;= ch \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) { x = x * 10 + ch - \u0026#39;0\u0026#39;; ch = getchar(); } return x * f; } int main() { n = read(); tot = 1; for (int i = 1; i \u0026lt;= n; i++) L[i] = i - 1, R[i] = i + 1; R[0] = 1; L[n+1] = n; for (int i = 1; i \u0026lt;= n; i++) { int opt = read(), x = read(); if(opt == 1) { if(a[x] == 0) { if(x == tot) tot++; // tot 表示当前从 1 开始连续 1 的最后一个位置 if(a[tot] == 1 \u0026amp;\u0026amp; tot \u0026lt;= n) tot = (tot - 1) + b[tot - 1] + 1; L[R[x]] = L[x]; R[L[x]] = R[x]; if(a[L[x]] == 0) b[L[x]] += b[x] + 1; } a[x] = 1; } else { if(x != 1 \u0026amp;\u0026amp; a[1] == 0) { puts(\u0026#34;1\u0026#34;); continue; } if(x == 1 \u0026amp;\u0026amp; a[1] == 0) { puts(\u0026#34;2\u0026#34;); continue; } if(a[x] == 1) printf(\u0026#34;%d\\n\u0026#34;, tot); else { if(tot == x) printf(\u0026#34;%d\\n\u0026#34;,tot + b[x] + 1); else printf(\u0026#34;%d\\n\u0026#34;, tot); } } } return 0; }// 0 1 0 1 1 1. 优先队列的比较函数是反的。\n2. 卡特兰数的 $4$ 个公式。\n组合公式 ：\n1. h(n) = C(2n, n) / (n + 1) = C(n - 1, 2n) / n 递推公式 ：\n1. h(n) = h(n - 1) * (4 * n - 2) / (n + 1) 3. $lucas$\n1 2 3 4 5 6 7 8 int C(int n, int m, int p) { return n \u0026lt; m ? 0 : (fact[n] * q_pow(fact[m], p - 2, p) % p * q_pow(fact[n - m], p - 2, p ) % p); } int lucas(int n, int m, int p) { return m == 0 ? 1 : lucas(n / p, m / p, p) * C(n % p, m % p, p) % p; } 4. 阶乘求组合数\n1 2 3 4 5 6 7 8 9 10 11 12 13 void init()//预处理阶乘和阶乘的逆元 { fac[0] = 1; int maxn = 200000; for(int i = 1;i \u0026lt;= maxn; i++) fac[i] = (fac[i - 1] * i) % mod; inv[maxn] = q_pow (fac[maxn], mod - 2); for(int i = maxn - 1;i \u0026gt;= 0; i--) inv[i] = (inv[i + 1] * (i + 1)) % mod; } int C(int n, int m) { if (n \u0026lt; m || n \u0026lt; 0 || m \u0026lt; 0) return 0; return (fac[n] * inv[m]) % mod * inv[n - m] % mod; } 5. 递推求逆元\n1 2 3 4 5 6 inv[1] = 1; for(int i = 2; i \u0026lt;= n; i++) { inv[i] = (p - p / i) * inv[p % i] % p; printf(\u0026#34;%lld\\n\u0026#34;, inv[i]); } 6. $1 - n$ 所有数的最小公倍数等于每个素数最高次幂的连乘。\n1 2 3 4 5 if(!isp[i]) // 是素数 { tot++, pri[tot] = i; for (int j = i; j \u0026lt;= n; j *= i) ans = (ans * i) % mod; } $1 - n$ 所有数的最大公约数等于每个素数最小次幂的连乘\n7. 错位排列问题:\n8. 只有一个质因子的数是一个素数的幂次。\n9. $LIS$ $nlogn$ 求法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void LIS() { int now = 0; memset(f, 0xcf, sizeof(f)); for (int i = 1; i \u0026lt;= n; i++) { if(f[now] \u0026lt; a[i]) now++, f[now] = a[i], L[i] = now; else { t = lower_bound(f + 1, f + now + 1, a[i]) - f; f[t] = a[i]; L[i] = t; // L[i] 为到 i 时的 LIS } } } 10. 平方和公式：\n$1^2 + 2^2 + 3^2 + \u0026hellip; + n^2 = \\frac{n(n + 1)(2 \\times n + 1)}{6}$\n11. 整除分块\n一般求解这样的式子：$\\sum_{i=1}^nn/i$。\n1 2 3 4 5 for(int l = 1, r; l \u0026lt;= n; l = r + 1) { r = n / (n / l); ans += (r - l + 1) * (n / l); } 状压枚举子集： 1 2 3 4 5 6 7 8 for (int i = 0; i \u0026lt;= m; i++) { for (int j = i; ; j = i \u0026amp; (j - 1)) { if(W[i ^ j] \u0026lt;= w) f[i] = min(f[i], f[j] + T[i ^ j]); // dp 部分 if(!j) break; } } KMP 1.求 $nxt$ 1 2 3 4 5 6 7 8 9 10 11 void pre() { p[1] = 0; // p 就是 nxt int j = 0; for (int i = 1; i \u0026lt; lenb;i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; b[j + 1] != b[i + 1]) j = p[j]; if (b[j + 1] == b[i + 1]) j++; p[i + 1] = j; } } 2.匹配 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void work() { int j = 0; for (int i = 1; i \u0026lt;= lena; i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; b[j + 1] != a[i]) j = p[j]; if (b[j + 1] == a[i]) j++; pos[i] = j; if (j == lenb) { cout \u0026lt;\u0026lt; i - lenb + 1 \u0026lt;\u0026lt; endl; // 每次出现的位置 j = p[j]; } } } 3.求最小正周期 $len2 - p[len2]$\n4.所有的公共前后缀 最长 ： $l1 = nxt_{len}$\n次长 ： $l2 = nxt_{l1}$\n$l3 = nxt_{l2}$\n$l4 = nxt_{l3}$\n\u0026hellip;\u0026hellip;\n字符串相关术语 LPS: Longest Palindrome Subsequence 最长回文子序列 LCS: Longest Common Subsequence 最长公共子序列 LCP：Longest Common Prefix 最长公共前缀 一些结论 已知正整数数组的最后元素为 $a_m$，且数组单调不降，那么满足条件的数组个数为 ： $C_{a_m+(m-1)-1}^{m-1}$\n斯特林数 1 第二类斯特林数$\\begin{Bmatrix}n\\k\\end{Bmatrix}$\n$n$ 个不同的球，放进 $k$ 个相同的盒子，不能有空盒子的方案数。\n递推：\nS(n, k) = S(n − 1, k − 1) + k × S(n − 1, k) 通项公式（容斥）：\ni = 0 ~ k, (inv[i] * inv[k - i]) *(i%2?-1:1) * qpow(k - i,n) 约数个数与约数和定理 约数个数与约数和定理\n数树 $n$ 个不同的点能组成 $n^{n-1}$ 个不同的有根树，$n^{n-2}$ 个不同的无根树\n全排列函数 ： next_permutation(a + 1, a + 1 + n) setd的比较函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 struct Compare { bool operator()(const int x, const int y) const { return x \u0026gt; y; } }; int main() { multiset\u0026lt;int, Compare\u0026gt; s; n = rd(); for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; s.insert(a[i]); } for (auto \u0026amp;x:s) { cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } __$builtin_popcount(x)$ : 计算 $x$ 二进制中有多少个 $1$\n1 2 3 4 5 6 7 8 9 struct node { int x, y; bool operator\u0026lt;(const node \u0026amp;u) const { return x \u0026gt; u.x; } }; priority_queue\u0026lt;node\u0026gt; Q[N]; ","date":"2025-11-16T20:30:49+08:00","image":"https://dangdaizheshi.github.io/myblog/p/%E4%B8%80%E4%BA%9B%E7%BB%8F%E5%B8%B8%E5%BF%98%E8%AE%B0%E7%9A%84%E4%B8%9C%E8%A5%BF/matt-le-SJSpo9hQf7s-unsplash_hu10664154974910995856.jpg","permalink":"https://dangdaizheshi.github.io/myblog/p/%E4%B8%80%E4%BA%9B%E7%BB%8F%E5%B8%B8%E5%BF%98%E8%AE%B0%E7%9A%84%E4%B8%9C%E8%A5%BF/","title":"一些经常忘记的东西"},{"content":"DDL（数据定义语言） 添加和删除外键 1 2 3 alter table emp add constraint fkl foreign key (dept_id) references dept(id); --添加 alter table emp drop foreign key fkl; --删除 数据库操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 --查询所有数据库 show databases; --查询当前数据库 select database(); --创建一个名为 emp 的数据库 create database [ if not exists ] emp; --删除 emp 数据库 drop database [ if exists ] emp; --切换到 emp 数据库 use emp; 数据表操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 --查询当前数据库所有表 show tables; --查询表 news 结构 desc news; --查询建表语句 show create table news; --创建表 create table news( id int [ comment \u0026#39;编号\u0026#39; ], name varchar(50) [ comment \u0026#39;名称\u0026#39; ], gender char(1) [ comment \u0026#39;性别\u0026#39; ] ) [ comment \u0026#39;个人信息表\u0026#39; ]; --添加字段 alter table news add age int [ comment \u0026#39;年龄\u0026#39; ]； --修改某个字段 alter table news change nickname username varchar(30) [ comment \u0026#39;昵称\u0026#39; ]; --删除字段 alter table news drop name; --修改表名 alter table news rename to tb_user; --删除表 drop table [ if exists ] news; DML（数据操作语言） 添加数据 1 2 3 4 5 6 7 8 9 --指定字段 insert into news (字段名1, 字段名2, ...) values (值1, 值2, ...); --全部字段 insert into news values (值1, 值2, ...); --批量添加数据 insert into news (字段名1, 字段名2, ...) values (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...); insert into news values (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...); 更新和删除数据 1 2 3 4 5 --修改数据 update news set name = \u0026#39;张三\u0026#39;, age = 18, ... [ where id = 1 ]; --删除数据 delete from news [ where gender = \u0026#39;女\u0026#39; ]; DQL（数据查询语言） 基础查询 1 2 3 4 5 6 7 8 9 10 11 --查询 name, age, id select name, age, id from news; --查询整张表 select * from news; --设置别名 select name as \u0026#39;名字\u0026#39;, age as \u0026#39;年龄\u0026#39;, id as \u0026#39;编号\u0026#39; from news; --去重 select distinct age from news; 条件查询 1 2 3 4 5 6 7 8 9 10 11 --查询年龄在25 到 30的学生 select * from news where age \u0026gt;= 25 \u0026amp;\u0026amp; age \u0026lt;= 30; --查询没有身份证的学生 select * from news where id is null; --查询名字为两个字的 select * from news where name like \u0026#39;__\u0026#39; --身份证最后为X select * from news where id like \u0026#39;%X\u0026#39;; 分组查询 1 2 3 4 5 6 7 8 9 10 --根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女） select count(*) from employee group by gender; --根据性别分组，统计男性和女性数量 select gender, count(*) from employee group by gender; --根据性别分组，统计男性和女性的平均年龄 select gender, avg(age) from employee group by gender; --年龄小于45，并根据工作地址分组 select workaddress, count(*) from employee where age \u0026lt; 45 group by workaddress; --年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址 select workaddress, count(*) address_count from employee where age \u0026lt; 45 group by workaddress having address_count \u0026gt;= 3; 排序查询 1 2 3 4 5 -- 根据年龄升序排序 select * from employee order by age asc; --两字段排序，根据年龄升序排序，入职时间降序排序 select * from employee order by age asc, entrydate desc; 约束 1 2 3 4 5 6 7 create table user( id int primary key auto_increment, name varchar(10) not null unique, age int check(age \u0026gt; 0 and age \u0026lt; 120), status char(1) default \u0026#39;1\u0026#39;, gender char(1) ); 多表查询 联合查询 1 2 3 4 5 6 7 8 9 --含重复 select * from emp where age \u0026gt;= 50 union all select * from emp where score \u0026gt;= 600; --不重复 select * from emp where age \u0026gt;= 50 union select * from emp where score \u0026gt;= 600; 子查询 1 2 3 4 5 6 7 8 9 --查询销售部所有员工 select id from dept where name = \u0026#39;销售部\u0026#39;; --根据销售部部门ID，查询员工信息 select * from employee where dept = 4; --合并（子查询） select * from employee where dept = (select id from dept where name = \u0026#39;销售部\u0026#39;); --查询xxx入职之后的员工信息 select * from employee where entrydate \u0026gt; (select entrydate from employee where name = \u0026#39;xxx\u0026#39;); 列子查询 1 2 3 4 5 6 7 8 --查询销售部和市场部的所有员工信息 select * from employee where dept in (select id from dept where name = \u0026#39;销售部\u0026#39; or name = \u0026#39;市场部\u0026#39;); --查询比财务部所有人工资都高的员工信息 select * from employee where salary \u0026gt; all(select salary from employee where dept = (select id from dept where name = \u0026#39;财务部\u0026#39;)); --查询比研发部任意一人工资高的员工信息 select * from employee where salary \u0026gt; any (select salary from employee where dept = (select id from dept where name = \u0026#39;研发部\u0026#39;)); 行子查询 1 2 3 --查询与xxx的薪资及直属领导相同的员工信息 select * from employee where (salary, manager) = (12500, 1); select * from employee where (salary, manager) = (select salary, manager from employee where name = \u0026#39;xxx\u0026#39;); 表子查询 1 2 3 4 5 --查询与xxx1，xxx2的职位和薪资相同的员工 select * from employee where (job, salary) in (select job, salary from employee where name = \u0026#39;xxx1\u0026#39; or name = \u0026#39;xxx2\u0026#39;); --查询入职日期是2006-01-01之后的员工，及其部门信息 select e.*, d.* from (select * from employee where entrydate \u0026gt; \u0026#39;2006-01-01\u0026#39;) as e left join dept as d on e.dept = d.id; 外连接 1 2 --查询 emp 表的所有数据和 dept 表的某些数据 select e.*, d.name from emp e left join dept d on e.dept_id = d.id; ","date":"2025-11-14T14:10:49+08:00","image":"https://dangdaizheshi.github.io/myblog/p/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu6307248181568134095.jpg","permalink":"https://dangdaizheshi.github.io/myblog/p/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"mysql数据库学习笔记"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://dangdaizheshi.github.io/myblog/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu6307248181568134095.jpg","permalink":"https://dangdaizheshi.github.io/myblog/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://dangdaizheshi.github.io/myblog/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu10664154974910995856.jpg","permalink":"https://dangdaizheshi.github.io/myblog/p/placeholder-text/","title":"Placeholder Text"}]